function out = nirs_MCsegment_PVE(job)
% Cl2;ent Bonnéry 01/08/2011
% Ajouts Michèle oct 2011

% Segmented volume for simulation
[dir,name,ext] = fileparts(job.T1seg);
V = spm_vol(job.T1seg);
Y = spm_read_vols(V);

if isfield(job,'xSPM') && ~isempty(job.xSPM)
    % For mask from BOLD data %
    % ----------------------- %
    xSPM = job.xSPM; % xSPM matrix generated by spm_results_ui

    Ymask = zeros(xSPM.DIM');
    for i=1:size(xSPM.XYZ,2) % place values at right coordinates
        Ymask(xSPM.XYZ(1,i),xSPM.XYZ(2,i),xSPM.XYZ(3,i))=xSPM.Z(1,i);
    end
    % xSPM.M : transform vox -> mm coordinates in BOLD space
    % V.mat : vox -> mm in anat (simulation medium) space
    affine = V.mat\xSPM.M;

elseif isfield(job,'user_mask') && ~isempty(job.user_mask)    
    % For user-specified mask %
    % ----------------------- %
    Vmask = spm_vol(job.user_mask);
    Ymask = spm_read_vols(Vmask);
    affine = V.mat\Vmask.mat;
end

% The following lines are equivalent to rY_vxT1 = V.mat\(xSPM.M*rY);
T = maketform('affine',affine');
R = makeresampler('nearest','bound');
rY_vxT1 = tformarray(Ymask,T',R,[1 2 3],[1 2 3],V.dim,[],[]);

% Segments the BOLD image and adds it to simulation volume as a 6th layer
Yf = Y + 6*(rY_vxT1>0);

pve_n = fullfile(job.cs_dir,['PVE' name ext]);
if ~exist(job.cs_dir), mkdir(job.cs_dir), end
Vpve = struct('fname',pve_n,...
    'dim',  V.dim,...
    'dt',   V.dt,...
    'pinfo',V.pinfo,...
    'mat',  V.mat);
Vpve = spm_create_vol(Vpve);
spm_write_vol(Vpve,Yf);

out = pve_n;
end

% % % 
% % Vbold = struct('fname',fullfile(job.cs_dir,'boldmask.nii'),...
% %     'dim',  xSPM.DIM',...
% %     'dt',   V.dt,...
% %     'pinfo',V.pinfo,...
% %     'mat',  xSPM.M);
% % Vbold = spm_create_vol(Vbold);
% % spm_write_vol(Vbold,Ymask);
% % 
% xi = 0:1:xSPM.DIM(1)-1;
% yi = 0:1:xSPM.DIM(2)-1;
% zi = 0:1:xSPM.DIM(3)-1;
% % 
% % % 
% % % V = spm_vol(outRS);
% % % Yb = spm_read_vols(V);
% % % threshold=0;
% % % Yf = Y + 6*(Yb>threshold);
% % % %%%%%% 
% %    
% % % % 
% % %%%%%% autre methode< On utilise V.mat et comme ca on est direct dans le
% % %%%%%% bon espace mais il faut interoler point a point (on peut pas utiliser resize)
% % % % count=0;
% % for i=1:size(XYZmm,2)
% %     XYZ_vxT1seg(:,i) = V.mat\[XYZmm(:,i);1];
% %     Ybold_vxT1seg(XYZ_vxT1seg(1,i),XYZ_vxT1seg(2,i),XYZ_vxT1seg(3,i))=xSPM.Z(1,i);
% % end
% % Yb = zeros(V.dim);
% % %%%%%%%%%% interpolation
% % xi = XYZ_vxT1seg(1,:);
% % yi = XYZ_vxT1seg(2,:);
% % zi = XYZ_vxT1seg(3,:);
% 
% xf = 0:1:V.dim(1)-1;
% yf = 0:1:V.dim(2)-1;
% zf = 0:1:V.dim(3)-1;
% % Make grids, to use with 3-dimensional interpolation
% [xi1,yi1,zi1] = meshgrid(xi,yi,zi);
% [xf1,yf1,zf1] = meshgrid(xf,yf,zf);
% 
% Ybold_p = permute(Ymask,[2,1,3]);
% rY_p = interp3(xi1,yi1,zi1,Ybold_p,xf1,yf1,zf1,'nearest');
% rY = permute(rY_p,[2,1,3]);