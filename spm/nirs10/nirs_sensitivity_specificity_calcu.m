function [sen_spe render_proj] = nirs_sensitivity_specificity_calcu(...
    thres,dat,brt,TOPO,rend,sessions,views)
% Render blobs on surface of a 'standard' brain
% FORMAT spm_render(dat,brt,rendfile)
%
% dat      - a struct array of length 1 to 3
%            each element is a structure containing:
%            - XYZ - the x, y & z coordinates of the transformed SPM{.}
%                    values in units of voxels.
%            - t   - the SPM{.} values.
%            - mat - affine matrix mapping from XYZ voxels to MNI.
%            - dim - dimensions of volume from which XYZ is drawn.
% brt      - brightness control:
%            If NaN, then displays using the old style with hot
%            metal for the blobs, and grey for the brain.
%            Otherwise, it is used as a ``gamma correction'' to
%            optionally brighten the blobs up a little.
% rendfile - the file containing the images to render on to (see also
%            spm_surf.m) or a surface mesh file.
%
% TOPO     - the TOPO file generated by NIRS_SPM
%
%
%__________________________________________________________________________
%
% spm_render prompts for details of up to three SPM{.}s that are then
% displayed superimposed on the surface of a 'standard' brain.
%
% The first is shown in red, then green then blue.
%
% The blobs which are displayed are the integral of all transformed t
% values, exponentially decayed according to their depth. Voxels that
% are 10mm behind the surface have half the intensity of ones at the
% surface.
%__________________________________________________________________________
% Molecular and Optical Imaging Laboratory
% Ke Peng
% 2012-08-20

%============================Configurations================================

num     = length(dat);
%define the colours for focus and contrasts display
% col_focus = eye(3);%Red
% col_contrast = [0,0,1;0,1,0;0,0,1];%Blue

%Load the render file
% [p,f,e] = fileparts(rendfile);
% loadgifti = false;
% if strcmpi(e,'.mat')
%     load(rendfile);
%     if ~exist('rend','var') && ~exist('Matrixes','var')
%         loadgifti = true;
%     end
% end
% if ~strcmpi(e,'.mat') || loadgifti
%     try
%         rend = export(gifti(rendfile),'patch');
%     catch
%         error('\nCannot read  render file "%s".\n', rendfile);
%     end
%     if num == 1
%         col = hot(256);
%     else
%         col = eye(3);
%         if spm_input('Which colours?','!+1','b',{'RGB','Custom'},[0 1],1)
%             for k = 1:num
%                 col(k,:) = uisetcolor(col(k,:),sprintf('Colour of blob set %d',k));
%             end
%         end
%     end
%     surf_rend(dat,rend,col);
%     return
% end

% spm('Pointer','Watch');

% if ~exist('rend','var') % Assume old format...
%     rend = cell(size(Matrixes,1),1);
%     for brain_view=1:size(Matrixes,1),
%         rend{brain_view}=struct('M',eval(Matrixes(brain_view,:)),...
%             'ren',eval(Rens(brain_view,:)),...
%             'dep',eval(Depths(brain_view,:)));
%         rend{brain_view}.ren = rend{brain_view}.ren/max(max(rend{brain_view}.ren));
%     end
% end

% %Display Calibration
% Fgraph = spm_figure('GetWin','Graphics');
% spm_results_ui('Clear',Fgraph);
%
% nrow = ceil(length(views)/2);
% % subplot('Position',[0, 0, 1, hght]);
% hght = 0.95;
% ax=axes('Parent',Fgraph,'units','normalized','Position',[0, 0, 1, hght],'Visible','off');
% image(0,'Parent',ax);
% set(ax,'YTick',[],'XTick',[]);

%Create structure to restore focus render map and contrast render map
try
    render_proj.focus = cell(1,length(dat));
    %     render_proj.all_focus = cell(1,length(rend));
    for z0 = 1 : length(dat)
        render_proj.focus{z0} = struct();
        render_proj.focus{z0}.num = z0;
        render_proj.focus{z0}.f_map = cell(1,length(rend));
    end
    
    render_proj.contrast = cell(1,length(TOPO.v{3}.s)); %Take Dorsal view to obtain the session number
    for s0 = 1 : length(render_proj.contrast)
        render_proj.contrast{s0} = struct();
        render_proj.contrast{s0}.session = s0;
        render_proj.contrast{s0}.c_map = cell(1,length(rend));
    end
    
catch
    disp('Error when creating render_proj');
end

%===================Render the epileptic focus (sixviews)==================

for brain_view=1:length(rend),
    rend{brain_view}.max=0;
    rend{brain_view}.data = cell(size(dat,1),1);
    if issparse(rend{brain_view}.ren),
        % Assume that images have been DCT compressed
        % - the SPM99 distribution was originally too big.
        d = size(rend{brain_view}.ren);
        B1 = spm_dctmtx(d(1),d(1));
        B2 = spm_dctmtx(d(2),d(2));
        rend{brain_view}.ren = B1*rend{brain_view}.ren*B2';
        % the depths did not compress so well with
        % a straight DCT - therefore it was modified slightly
        rend{brain_view}.dep = exp(B1*rend{brain_view}.dep*B2')-1;
    end
    rend{brain_view}.ren(rend{brain_view}.ren>=1) = 1;
    rend{brain_view}.ren(rend{brain_view}.ren<=0) = 0;
    
end

mx = zeros(length(rend),1)+eps;
mn = zeros(length(rend),1);

XYZ = dat.XYZ;
t   = dat.Z'; %modified for NIRS
dim = dat.DIM; %modified for NIRS
mat = dat.M; %modified for NIRS

for brain_view=1:length(rend),
    
    % transform from Talairach space to space of the rendered image
    %------------------------------------------------------------------
    M1  = rend{brain_view}.M*mat;
    zm  = sum(M1(1:2,1:3).^2,2).^(-1/2);
    M2  = diag([zm' 1 1]);
    M  = M2*M1;
    cor = [1 1 1 ; dim(1) 1 1 ; 1 dim(2) 1; dim(1) dim(2) 1 ;
        1 1 dim(3) ; dim(1) 1 dim(3) ; 1 dim(2) dim(3); dim(1) dim(2) dim(3)]';
    tcor= M(1:3,1:3)*cor + M(1:3,4)*ones(1,8);
    off = min(tcor(1:2,:)');
    M2  = spm_matrix(-off+1)*M2;
    M  = M2*M1;
    xyz = (M(1:3,1:3)*XYZ + M(1:3,4)*ones(1,size(XYZ,2)));
    d2  = ceil(max(xyz(1:2,:)'));
    
    % Calculate 'depth' of values
    %------------------------------------------------------------------
    if ~isempty(d2)
        dep = spm_slice_vol(rend{brain_view}.dep,spm_matrix([0 0 1])*inv(M2),d2,1);
        z1  = dep(round(xyz(1,:))+round(xyz(2,:)-1)*size(dep,1));
        
        if ~isfinite(brt), msk = find(xyz(3,:) < (z1+20) & xyz(3,:) > (z1-5));
        else msk = find(xyz(3,:) < (z1+60) & xyz(3,:) > (z1-5)); end
    else
        msk = [];
    end
    
    if ~isempty(msk),
        
        % Generate an image of the integral of the blob values.
        %--------------------------------------------------------------
        xyz = xyz(:,msk);
        if ~isfinite(brt), t0  = t(msk);
        else
            dst = xyz(3,:) - z1(msk);
            dst = max(dst,0);
            t0  = t(msk).*exp((log(0.5)/10)*dst)';
        end
        X0  = full(sparse(round(xyz(1,:)), round(xyz(2,:)), t0, d2(1), d2(2)));
        hld = 1; if ~isfinite(brt), hld = 0; end
        X   = spm_slice_vol(X0,spm_matrix([0 0 1])*M2,size(rend{brain_view}.dep),hld);
        msk = find(X<0);
        X(msk) = 0;
    else
        X = zeros(size(rend{brain_view}.dep));
    end
    
    % Brighten the blobs
    %------------------------------------------------------------------
    if isfinite(brt), X = X.^brt; end
    
%     mx(brain_view) = max([mx(brain_view) max(max(X))]);
%     mn(brain_view) = min([mn(brain_view) min(min(X))]);
%     
    rend{brain_view}.data_focus = X;
    
    %Write the view name
    %------------------------------------------------------------------
    render_proj.focus{z0}.f_map{brain_view}.data = X;
    [side_hemi spec_hemi] = nirs_get_brain_view(brain_view);
    render_proj.focus{z0}.f_map{brain_view}.view = side_hemi;
end

%Do not need the following codes as we only indicate one focus for one
%subject at this moment
%Ke Peng 2012-11-06
%**************************************************************************
% if ~isempty(dat) %If more than one focus is indicated, add all the focus maps
%     for i = 1 : length(rend)
%         render_proj.all_focus{i} = struct();
%         render_proj.all_focus{i}.view = render_proj.focus{1}.f_map{i}.view;
%         render_proj.all_focus{i}.map = zeros(size(render_proj.focus{1}.f_map{i}.data));
%         for j=1:length(dat)
%             render_proj.all_focus{i}.map = render_proj.all_focus{i}.map + render_proj.focus{j}.f_map{i}.data;
%         end
%         render_proj.all_focus{i}.map(find(render_proj.all_focus{i}.map > 1)) = 1; %#ok<FNDSB>
%     end
% end
%
% clear i j

%One focus map (in six views) ready to use

%=====================Render the contrasts (Manually) =====================

for s0 = sessions
    for v0 = [3 4] %views
        %Need to add options for the chromophore and the contrast type
        con_XYZ = squeeze(TOPO.v{v0}.s{s0}.hb{2}.stat_map(1,:,:)); %To project HbR concentration as a first stage. Only have the first activation.
        
        %Remove massive interpolation
        if isfield(rend{v0},'view_mask_2d') % for back-compatibility
            con_XYZ = con_XYZ .* rend{v0}.view_mask_2d;
        end
        %con_XYZ_co = [];
        
        %Apply the threshold value
        if thres
            if isfield(TOPO.v{v0}.s{s0}.hb{2}, 'th_z') %Corresponding to HbR
                if isfield(TOPO.v{v0}.s{s0}.hb{2}.th_z{1}, 'positive_thz') %Corresponding to the first activation
                    thz_p = TOPO.v{v0}.s{s0}.hb{2}.th_z{1}.positive_thz;
                    con_p = con_XYZ;
                    con_p((con_XYZ - thz_p) <= 0) = 0;
                end
                if isfield(TOPO.v{v0}.s{s0}.hb{2}.th_z{1}, 'negative_thz')
                    thz_n = TOPO.v{v0}.s{s0}.hb{2}.th_z{1}.negative_thz;
                    con_n = con_XYZ;
                    con_n((con_XYZ + thz_n) >= 0) = 0;
                end
                
                if exist('con_p', 'var') && exist('con_n', 'var')
                    con_XYZ = con_p + con_n;
                    clear con_p con_n
                elseif exist('con_p', 'var')
                    con_XYZ = con_p;
                    clear con_p
                elseif exist('con_n', 'var')
                    con_XYZ = con_n;
                    clear con_n;
                else
                    con_XYZ = zeros(size(con_XYZ));
                end
                
            else
                %No corrected image
                con_XYZ = zeros(size(con_XYZ));
            end
        end
        
        %Negative values to Positive values
        con_XYZ = abs(con_XYZ);
        %
        
        %Restore separately
        switch v0
            case 1
                disp('Ventral view is not supported at this stage. Please select a different view');
            case 2
                %Dorsal View
                con_XYZ = flipud(con_XYZ);%Upside down
            case 3
                %Left View
                con_XYZ = flipud(con_XYZ);
            case 4
                %Right View
                con_XYZ = flipud(con_XYZ);
            case 5
                %Frontal View
                con_XYZ = flipud(con_XYZ);
            case 6
                disp('Occipital view is not supported at this stage. Please select a different view');
            otherwise
                disp('Unknown view selected. Please verify.');
        end
        
        mxmx = max(max(con_XYZ));
        mnmn = min(min(con_XYZ));
        
        render_proj.contrast{s0}.c_map{v0} = struct();
        render_proj.contrast{s0}.c_map{v0}.view_no = v0;
        
        [side_hemi spec_hemi] = nirs_get_brain_view(v0);
        render_proj.contrast{s0}.c_map{v0}.view = side_hemi;
        %loop over different clusters of activation?
        render_proj.contrast{s0}.c_map{v0}.data{1} = con_XYZ;%Modify when adding multiple activations
        render_proj.contrast{s0}.c_map{v0}.mxmx{1} = mxmx;
        render_proj.contrast{s0}.c_map{v0}.mnmn{1} = mnmn;
        
    end
    
end

%Contrasts data ready to use

%==========================================================================
%**************************************************************************
%No need to display, we have to compare the focus and contrasts to give a
%judgement of sensitivity and specificity.

sen_spe = struct();
sen_spe.sen_spe_detail = cell(1,length(sessions));
sen_spe.sen_spe_over_all_sessions = cell(1,3);
sen_spe.sen_spe_over_all_sessions{1}.chromophore = 'HbR';


sen = [];
spe = [];

for s0 = sessions
    
    %First access HbR
    sen_spe.sen_spe_detail{s0}.session = s0;
    sen_spe.sen_spe_detail{s0}.chromophore = cell(1,3);
    sen_spe.sen_spe_detail{s0}.chromophore{1}.name = 'HbR';
    [focus_cover co] = check_coverage(render_proj.focus{1}.f_map,rend);%Check coverage of focus
    [sen_spe.sen_spe_detail{s0}.chromophore{1}.sensitivity sen_spe.sen_spe_detail{s0}.chromophore{1}.overlap_f_cmap_percentage] = ...
        sensentivity_judge(render_proj.focus{1}.f_map, render_proj.contrast{s0}.c_map, focus_cover, co);
    sen = [sen;sen_spe.sen_spe_detail{s0}.chromophore{1}.sensitivity];%Restore result for each session
    [sen_spe.sen_spe_detail{s0}.chromophore{1}.specificity sen_spe.sen_spe_detail{s0}.chromophore{1}.overlap_f_largest_cluster_percentage] = ...
        specificity_judge(render_proj.focus{1}.f_map, render_proj.contrast{s0}.c_map, focus_cover, co);
    spe = [spe;sen_spe.sen_spe_detail{s0}.chromophore{1}.specificity];
    
end

if ~isempty(find(sen == 1))
    sen_spe.sen_spe_over_all_sessions{1}.sensitivity = 1;
else
    if ~isempty(find(sen == 0))
        sen_spe.sen_spe_over_all_sessions{1}.sensitivity = 0;
    else
        sen_spe.sen_spe_over_all_sessions{1}.sensitivity = NaN;
    end
end

if ~isempty(find(spe == 1))
    sen_spe.sen_spe_over_all_sessions{1}.specificity = 1;
else
    if ~isempty(find(spe == 0))
        sen_spe.sen_spe_over_all_sessions{1}.specificity = 0;
    else
        sen_spe.sen_spe_over_all_sessions{1}.specificity = NaN;
    end
end

%**************************************************************************
%function to check whether we have coverage on epileptic focus
%**************************************************************************

function [focus_cover co] = check_coverage(f_map,mask_2d)
%First judge whether the coverage area of optodes includes the focus
co = [];
lco = cell(1,6);
lf = cell(1,6);
for v0=1:6
    lf{v0} = f_map{v0}.data .* flipud(mask_2d{v0}.view_mask_2d);
    if max(lf{v0}(:))<=0 %Not detected
        lco{v0} = 0;
    else
        lco{v0} = 1;
    end
    co = [co lco{v0}];
end

if (~lco{3}) && (~lco{4})
    %Not detected in either view
    %Judgement sentence whether we have coverage. Possibly needs modification!
    focus_cover = NaN;
    co = [];
else
    focus_cover = 1;
end


%**************************************************************************
%function to judge sensitivity of a certain session of a subject
%**************************************************************************

function [sen_out sz_ov] = sensentivity_judge(f_map,c_map,focus_cover,co)

if isnan(focus_cover)
    sen_out = NaN;
    sz_ov = [];
else
    %if cover the focus
    av = [];
    sz_ov = [];
    
    for v0 = 2 : 5 %Check the 2/Dorsal 3/Right 4/Left 5/Frontal view
        if co(v0)
            sen_view = f_map{v0}.data .* c_map{v0}.data{1};
            av = [av max(sen_view(:))];%Record the max product of each view
            ov = find(sen_view);%get a list of voxels that are overlapped
            szov = length(ov);%See how many voxels are overlapped
            cmap = find(c_map{v0}.data{1});%get a list of cmap voxels
            sz_cmap = length(cmap);%See cmap contains how many voxels
            focus = find(f_map{v0}.data);%get a list of focus voxels
            sz_focus = length(focus);%See focus contains how many voxels
            sz_ov = [sz_ov [v0;(szov/sz_focus);(szov/sz_cmap)]];
            %Have an output like [view_no overlap/focus overlap/contrasts]
        end
    end
    
    sen = 1;
    if length(av) < 1
        sen = 0;
    else
        if ~isempty(find(av <= 0))
            %Has to have overlap on each view that we have coverage, but
            %possibly needs modification
            sen = 0;
        else
            sen = 1;
        end
    end
    
    if sen == 1
        sen_out = 1;
    else
        sen_out = 0;
    end
end

%**************************************************************************
%function to judge specificity of a certain session of a subject
%**************************************************************************
function [spe_out sz_ov] = specificity_judge(f_map,c_map,focus_cover,co)

if isnan(focus_cover)
    spe_out = NaN;
    sz_ov = [];
else
    sz_ov = [];
    no_ov = [];
    
    for v0 = 2 : 5 %Check the 2/Dorsal 3/Right 4/Left 5/Frontal view
        if co(v0)%if a certain view covers the focus
            [clu_map_dor clu_vx_no] = largest_cluster(c_map{v0}.data{1});%find the largest cluster in the c-map of the view
            ov_map = f_map{v0}.data .* clu_map_dor;%Get the overlap map of focus and largest cluster
            ov_index = find(ov_map);
            szov = length(ov_index);%calculate how many voxels are overlapped
            focus = find(f_map{v0}.data);%get a list of focus voxels
            sz_focus = length(focus);%See focus contains how many voxels
            sz_ov = [sz_ov [v0;clu_vx_no;(szov/sz_focus);(szov/clu_vx_no)]];
            %finally it will be like [view_no; voxels of largest cluster; sizeofoverlap/sizeoffocus sizeofoverlap/sizeoflargestcluster]
        else
            [clu_map_dor clu_vx_no] = largest_cluster(c_map{v0}.data{1});
            no_ov = [no_ov [v0;clu_vx_no]];
            %finally it will be like [view_no;voxels of largest cluster]
        end
    end
    
    spe_out = 0;
    for ov_0 = 1 : size(sz_ov, 2);
        if sz_ov(3,ov_0) > 0.05  %if overlap > 5% of focus, consider a effective overlap
            l_c_sz = sz_ov(2,ov_0);
            %Only overlapped with the largest cluster in one view, and in
            %other view there is no larger cluster.
            spe_out = 1;
            for nov_0 = 1 : size(no_ov, 2)
                if l_c_sz < no_ov(2,nov_0)
                    spe_out = 0;
                end
            end
        end
    end
    
end

%**************************************************************************

function [cluster_largest_map cluster_largest_vx_no] = largest_cluster(view_c_map)

[Lx Ly] = find(view_c_map); %Find places in c-map that are not 0
L = [Lx';Ly';ones(1,length(Lx))]; %Manuelly add one dimention (all 1s) to meet the 3-D coordinate input requirement for this function
A = spm_clusters(L); %Detect clusters for none-0 places in c-map
clusters_no = max(A); %Number of clusters in this c-map
cluster_area = zeros(1,clusters_no);
for cno = 1 : clusters_no
    cluster_area(cno) = length(find(A == cno)); %Area for each cluster
end
cluster_largest = find(cluster_area == max(cluster_area)); %find the largest cluster
cluster_largest_vx_no = cluster_area(cluster_largest);%Find the total number of voxels of the largest cluster
cluster_pos_largest = find(A == cluster_largest); %Find the corresponding position for the largest cluster
cluster_largest_map = zeros(size(view_c_map));
for p0 = 1 : length(cluster_pos_largest)
    cluster_largest_map(Lx(cluster_pos_largest(p0)), Ly(cluster_pos_largest(p0))) = view_c_map(Lx(cluster_pos_largest(p0)), Ly(cluster_pos_largest(p0)));
end


%==========================================================================
% function surf_rend(dat,rend,col)
%==========================================================================
function surf_rend(dat,rend,col)

%-Setup figure and axis
%--------------------------------------------------------------------------
Fgraph = spm_figure('GetWin','Graphics');
spm_results_ui('Clear',Fgraph);

ax0 = axes(...
    'Tag',      'SPMMeshRenderBackground',...
    'Parent',   Fgraph,...
    'Units',    'normalized',...
    'Color',    [1 1 1],...
    'XTick',    [],...
    'YTick',    [],...
    'Position', [-0.05, -0.05, 1.05, 0.555]);

ax = axes(...
    'Parent',   Fgraph,...
    'Units',    'normalized',...
    'Position', [0.05, 0.05, 0.9, 0.4],...
    'Visible',  'off');

H = spm_mesh_render('Disp',rend,struct('parent',ax));
spm_mesh_render('Overlay',H,dat,col);

try
    setAllowAxesRotate(H.rotate3d, setxor(findobj(Fgraph,'Type','axes'),ax), false);
end

%-Register with MIP
%--------------------------------------------------------------------------
try % meaningless when called outside spm_results_ui
    hReg = spm_XYZreg('FindReg',spm_figure('GetWin','Interactive'));
    xyz  = spm_XYZreg('GetCoords',hReg);
    hs   = mydispcursor('Create',ax,dat.mat,xyz);
    spm_XYZreg('Add2Reg',hReg,hs,@mydispcursor);
end


%==========================================================================
function varargout = mydispcursor(varargin)

switch lower(varargin{1})
    %======================================================================
    case 'create'
        %======================================================================
        % hMe = mydispcursor('Create',ax,M,xyz)
        ax  = varargin{2};
        M   = varargin{3};
        xyz = varargin{4};
        
        [X,Y,Z] = sphere;
        vx = sqrt(sum(M(1:3,1:3).^2));
        X = X*vx(1) + xyz(1);
        Y = Y*vx(2) + xyz(2);
        Z = Z*vx(3) + xyz(3);
        hold(ax,'on');
        hs = surf(X,Y,Z,'parent',ax,...
            'EdgeColor','none','FaceColor',[1 0 0],'FaceLighting', 'phong');
        set(hs,'UserData',xyz);
        
        varargout = {hs};
        
        %=======================================================================
    case 'setcoords'    % Set co-ordinates
        %=======================================================================
        % [xyz,d] = mydispcursor('SetCoords',xyz,hMe,hC)
        hMe  = varargin{3};
        pxyz = get(hMe,'UserData');
        xyz  = varargin{2};
        
        set(hMe,'XData',get(hMe,'XData') - pxyz(1) + xyz(1));
        set(hMe,'YData',get(hMe,'YData') - pxyz(2) + xyz(2));
        set(hMe,'ZData',get(hMe,'ZData') - pxyz(3) + xyz(3));
        set(hMe,'UserData',xyz);
        
        varargout = {xyz,[]};
        
        %=======================================================================
    otherwise
        %=======================================================================
        error('Unknown action string')
        
end
