function [SPM] = precoloring_batch(varargin)
% NIRS_SPM: this function is used for estimation of GLM parameters.
SPM = varargin{1};
Y = varargin{2};
overrideJ0 = 0;
if size(varargin) == 3
    J0 = varargin{3};
    overrideJ0 = 1;
end
[nScan nBeta] = size(SPM.xX.X);

% Set up of the filters / Design space and projector matrix [pseudoinverse] for WLS
%==================================================================
switch SPM.xX.K.HParam.type
    case 'Wavelet-MDL'
        tmp_K = SPM.xX.K;
        tmp_K.HParam.type = '';
        SPM.xX.xKXs = spm_sp('Set', spm_filter_HPF_LPF_WMDL(tmp_K, SPM.xX.X)); % KX
        SPM.xX.K.X = SPM.xX.X;
        clear tmp_K;
    case 'DCT'
        SPM.xX.xKXs = spm_sp('Set', spm_filter_HPF_LPF_WMDL(SPM.xX.K, SPM.xX.X)); % KX
    case 'none'
        SPM.xX.xKXs = spm_sp('Set', spm_filter_HPF_LPF_WMDL(SPM.xX.K, SPM.xX.X)); % KX ?
end

SPM.xX.xKXs.X = full(SPM.xX.xKXs.X);
SPM.xX.pKX = spm_sp('x-', SPM.xX.xKXs); % projector

%filtering of the data
KY = spm_filter_HPF_LPF_WMDL(SPM.xX.K, Y);
%For testing
%figure; nn = 8; plot(Y(:,nn)); hold on; plot(KY(:,nn),'r'); hold off

%GLM inversion: calculating beta and residuals - would be SPM.Vbeta,
%SPM.VResMS if we had full images as with fMRI
SPM.xX.beta = SPM.xX.pKX * KY; % beta : least square estimate
res = spm_sp('r', SPM.xX.xKXs, KY); % Residuals 
SPM.xX.ResSS = sum(res.^2); % Residual SSQ
%data no longer required
clear KY Y res

%more filtering operations
switch SPM.xX.K.LParam.type
    case {'hrf', 'Gaussian'}
        S = SPM.xX.K.KL;
    case 'none'
        S = speye(nScan);
end

switch SPM.xX.K.HParam.type 
    case 'DCT'
         S = S - SPM.xX.K.X0 * (SPM.xX.K.X0' * S);                                    
        %note NIRS_SPM has a catch if out of memory occurs (- deleted here)
end

%PP to speed up calculation of TrRV and TrRVRV
% M7 = (eye(nScan)-SPM.xX.xKXs.X * SPM.xX.pKX) * (S * S');
% trRV = trace(M7);
% close(h_wait);
% 
% h_wait = waitbar(0, 'Calculating the trace(RVRV)... Please wait.');
% trRVRV = trace(M7 * M7);
% close(h_wait);

%Difficulty with calculation of TrRV and especially TrRVRV is that the
%nScan values that contribute to the traces are very badly distributed,
%with a few very large values. Strategy is to calculate the values that
%contribute to TrRV exactly, and since the indices where they occur will
%be the same as for trRVRV, approximate trRVRV by those values.


trRV = 0;
trRVRV = 0;
%kk = 1:nScan;
%waitbar(kk/nScan, h_wait);

%computation of var1 and var2 is fairly quick
var1 = S * S';
var2 = var1 - SPM.xX.xKXs.X * (SPM.xX.pKX * var1); % RV * e(kk)
%var3 = var1*var2 is the long calculation - instead...
%find extreme values of var2
RVd = diag(var2);
RVs = std(RVd);
RVm = median(RVd);
k2 = RVd-RVm>RVs/10; %divide by a tenth of the std, but anytthing of order 1 would be fine
%largest contributions to var3
var3e = var1 * var2(:,k2);
RVRVde = diag(var3e(k2,:));
%find typical value of RVRV contribution:
sample_size = 100;
var3t = var1 * var2(:,1:sample_size);
RVRVt = median(diag(var3t(1:sample_size,:)));
trRVRV = sum(RVRVde) + RVRVt*(nScan-length(find(k2)));


var2t = var2(k2,k2);
var3 = S * (S' * var2t);
var4 = var3 - SPM.xX.xKXs.X * (SPM.xX.pKX * var3);

%var3 = S * (S' * var2);
    %var4 = var3 - SPM.xX.xKXs.X * (SPM.xX.pKX * var3);
    trRV = trRV + var2(kk);
    %trRVRV = trRVRV + var4(kk);
%end

%Calculate approximation of the trace by random sampling
sample_size = 100;
threshold = 0.01;
mtstream = RandStream('mt19937ar','Seed',0);
RandStream.setDefaultStream(mtstream);
%draw random numbers - ignore possible repetitions
rn = round(unifrnd(1,nScan,[sample_size,1]));
RVd = zeros(1,sample_size);
RVRVd = zeros(1,sample_size);
for kk=rn  
    var1 = S * S(kk,:)';
    var2 = var1 - SPM.xX.xKXs.X * (SPM.xX.pKX * var1); 
    var3 = S * (S' * var2);
    var4 = var3 - SPM.xX.xKXs.X * (SPM.xX.pKX * var3);
    
end
RVd = diag(var2(kk,:));
RVRVd = diag(var4(kk,:));
RV = median(RVd);
RVRV = median(RVRVd);
RVs = std(RVd);
RVRVs = std(RVRVd);
if RVs < threshold*RV && RVRVs < threshold*RVRV
    trRV = RV*nScan;
    trRVRV = RVRV*nScan;
else
    %
    disp('Calculating TrRV, TrRVRV with sample size of 1000');
    %Increase sample size
    sample_size = 1000;
    rn = round(unifrnd(1,nScan,[sample_size,1]));
    RVd = zeros(1,sample_size);
    RVRVd = zeros(1,sample_size);
    for kk=rn  
        var1 = S * S(kk,:)';
        var2 = var1 - SPM.xX.xKXs.X * (SPM.xX.pKX * var1); 
        var3 = S * (S' * var2);
        var4 = var3 - SPM.xX.xKXs.X * (SPM.xX.pKX * var3);
    end
    RVd = diag(var2(kk,:));
    RVRVd = diag(var4(kk,:));
    RV = median(RVd);
    RVRV = median(RVRVd);
    RVs = std(RVd);
    RVRVs = std(RVRVd);
    if RVs > threshold*RV || RVRVs > threshold*RVRV
        disp('Exceeded precision threshold for TrRV or TrRVRV - using last values found.');
    end
    trRV = RV*nScan;
    trRVRV = RVRV*nScan;
end

%In one example, "exact" calculation of trRV, trRVRV gave:
% 341.25, 238.84
%while truncation to 100 random samples gave
% 334.19 , 202.19
%and trunction to 1000 random samples gave
% 339.53, 206.81
%so the error is as much as 15%

% % h_wait = waitbar(0, 'Calculating the trace(RV)... Please wait.');
% % trRV = 0;
% % trRVRV = 0;
% % speedup = 50;
% % count = 0;
% % for kk=1:speedup:nScan  
% % %for kk = 1:floor(nScan/speedup)
% %     count = count + 1;
% %     %waitbar(kk/floor(nScan/speedup), h_wait);
% %     waitbar(kk/nScan, h_wait);
% %     var1 = S * S(kk,:)';
% %     var2 = var1 - SPM.xX.xKXs.X * (SPM.xX.pKX * var1); % RV * e(kk)
% %     var3 = S * (S' * var2);
% %     var4 = var3 - SPM.xX.xKXs.X * (SPM.xX.pKX * var3);
% %     trRV = trRV + var2(kk);
% %     trRVRV = trRVRV + var4(kk);
% % end
% % trRV = count * trRV;
% % trRVRV = count * trRVRV;
% % close(h_wait);


SPM.xX.trRV = trRV; % <R'*y'*y*R>
SPM.xX.trRVRV = trRVRV; %- Satterthwaite
SPM.xX.erdf = trRV^2/trRVRV;
% SPM.xX.Bcov = SPM.xX.pKX*V*SPM.xX.pKX';
SPM.xX.Bcov = (SPM.xX.pKX * S);
SPM.xX.Bcov = SPM.xX.Bcov * SPM.xX.Bcov';
%SPM.nirs.step = 'estimation';

try
    K = SPM.xX.K;
    K = rmfield(K, 'X');
    SPM.xX.K = K;
    %clear K;
end
end

% %heavy to call: large object S
% function [var2 var4] = trRVcore(kk,S, X, pK)
%     var1 = S * S(kk,:)';
%     var2 = var1 - X * (pX * var1); % RV * e(kk)
%     var3 = S * (S' * var2);
%     var4 = var3 - X * (pX * var3);
% end